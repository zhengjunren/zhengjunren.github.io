(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{539:function(e,t,a){"use strict";a.r(t);var v=a(29),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"list、set、map-之间的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list、set、map-之间的区别"}},[e._v("#")]),e._v(" List、Set、Map 之间的区别")]),e._v(" "),a("h2",{attrs:{id:"list-列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list-列表"}},[e._v("#")]),e._v(" List(列表)")]),e._v(" "),a("p",[a("code",[e._v("List")]),e._v("的元素以线性方式存储，可以存放重复对象，List主要有以下两个实现类：")]),e._v(" "),a("p",[a("code",[e._v("ArrayList")]),e._v(" : 长度可变的数组，可以对元素进行随机的访问，向"),a("code",[e._v("ArrayList")]),e._v("中插入与删除元素的速度慢。 JDK8 中"),a("code",[e._v("ArrayList")]),e._v("扩容的实现是通过"),a("code",[e._v("grow()")]),e._v("方法里使用语句"),a("code",[e._v("newCapacity = oldCapacity + (oldCapacity >> 1)")]),e._v("（即1.5倍扩容）计算容量，然后调用"),a("code",[e._v("Arrays.copyof()")]),e._v("方法进行对原数组进行复制。\n"),a("code",[e._v("LinkedList")]),e._v(": 采用链表数据结构，插入和删除速度快，但访问速度慢。")]),e._v(" "),a("h2",{attrs:{id:"set-集合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set-集合"}},[e._v("#")]),e._v(" Set(集合)")]),e._v(" "),a("p",[a("code",[e._v("Set")]),e._v("中的对象不按特定(HashCode)的方式排序，并且没有重复对象，"),a("code",[e._v("Set")]),e._v("主要有以下两个实现类：")]),e._v(" "),a("p",[a("code",[e._v("HashSet")]),e._v("： "),a("code",[e._v("HashSet")]),e._v("按照哈希算法来存取集合中的对象，存取速度比较快。当"),a("code",[e._v("HashSet")]),e._v("中的元素个数超过数组大小*loadFactor（默认值为0.75）时，就会进行近似两倍扩容"),a("code",[e._v("(newCapacity = (oldCapacity << 1) + 1)")]),e._v("。\n"),a("code",[e._v("TreeSet")]),e._v(" ："),a("code",[e._v("TreeSet")]),e._v("实现了"),a("code",[e._v("SortedSet")]),e._v("接口，能够对集合中的对象进行排序。")]),e._v(" "),a("h2",{attrs:{id:"map-映射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-映射"}},[e._v("#")]),e._v(" Map(映射)")]),e._v(" "),a("p",[a("code",[e._v("Map")]),e._v("是一种把键对象和值对象映射的集合，它的每一个元素都包含一个键对象和值对象。 Map主要有以下两个实现类：")]),e._v(" "),a("p",[a("code",[e._v("HashMap")]),e._v("："),a("code",[e._v("HashMap")]),e._v("基于散列表实现，其插入和查询"),a("code",[e._v("<K,V>")]),e._v("的开销是固定的，可以通过构造器设置容量和负载因子来调整容器的性能。\n"),a("code",[e._v("LinkedHashMap")]),e._v("：类似于HashMap，但是迭代遍历它时，取得"),a("code",[e._v("<K,V>")]),e._v("的顺序是其插入次序，或者是最近最少使用(LRU)的次序。\n"),a("code",[e._v("TreeMap")]),e._v("："),a("code",[e._v("TreeMap")]),e._v("基于红黑树实现。查看"),a("code",[e._v("<K,V>")]),e._v("时，它们会被排序。"),a("code",[e._v("TreeMap")]),e._v("是唯一的带有"),a("code",[e._v("subMap()")]),e._v("方法的"),a("code",[e._v("Map")]),e._v("，"),a("code",[e._v("subMap()")]),e._v("可以返回一个子树。")]),e._v(" "),a("h2",{attrs:{id:"原文链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原文链接"}},[e._v("#")]),e._v(" 原文链接")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/u012102104/java/article/details/79235938",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://blog.csdn.net/u012102104/java/article/details/79235938"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=_.exports}}]);