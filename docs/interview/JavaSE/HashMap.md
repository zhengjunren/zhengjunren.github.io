#  HashMap相关问题

## HashMap的底层原理是什么？
基于hashing的原理，jdk8后采用数组+链表+红黑树的数据结构。通过put和get存储和获取对象。当给put()方法传递键和值时，先对键做一个hashCode()的计算来得到它在bucket数组中的位置来存储Entry对象。当获取对象时，通过get获取到bucket的位置，再通过键对象的equals()方法找到正确的键值对，然后在返回值对象。

## HashMap中put是如何实现的？
1. 计算关于key的hashcode值（与Key.hashCode的高16位做异或运算）
2. 如果散列表为空时，调用resize()初始化散列表
3. 如果没有发生碰撞，直接添加元素到散列表中去
4. 如果发生了碰撞(hashCode值相同)，进行三种判断
    + 若key地址相同或者equals后内容相同，则替换旧值
    + 如果是红黑树结构，就调用树的插入方法
    + 链表结构，循环遍历直到链表中某个节点为空，尾插法进行插入，插入之后判断链表个数是否到达变成红黑树的阙值8；也可以遍历到有节点与插入元素的哈希值和内容相同，进行覆盖。
5. 如果桶满了大于阀值，则resize进行扩容

## HashMap中get是如何实现的？
对key的hashCode进行hashing，与运算计算下标获取bucket位置，如果在桶的首位上就可以找到就直接返回，否则在树中找或者链表中遍历找，如果有hash冲突，则利用equals方法去遍历链表查找节点。

## 为什么不直接将key作为哈希值而是与高16位做异或运算？
因为数组位置的确定用的是与运算，仅仅最后四位有效，设计者将key的哈希值与高16为做异或运算使得在做&运算确定数组的插入位置时，此时的低位实际是高位与低位的结合，增加了随机性，减少了哈希碰撞的次数。

## 初始化值为什么必须是2的幂？
HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；
这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&(length-1)，
hash%length==hash&(length-1)的前提是length是2的n次方；

扩容之后，原始数据的在数组中的数据要么不变，要么加上扩容之后的一半
