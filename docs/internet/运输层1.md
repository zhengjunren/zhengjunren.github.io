#  运输层-1

## 目录

[[toc]]

## 运输层协议概述

### 进程之间的通信
从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。
当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 

“逻辑通信”的意思是“好像是这样通信，但事实上并非真的这样通信”。
从IP层来说，通信的两端是两台主机。但“两台主机之间的通信”这种说法还不够清楚。
严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。
从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。

![网络层和运输层有明显的区别](/internet/5-1.png "网络层和运输层有明显的区别")

运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 

### 运输层的两个主要协议
TCP/IP 的运输层有两个主要协议：
1. 用户数据报协议 UDP (User Datagram Protocol)
2. 传输控制协议 TCP (Transmission Control Protocol)

#### 区别
UDP:
+ 无连接的协议，提供无连接服务；
+ 其传送的运输协议数据单元TPDU是 UDP 报文或用户数据报；
+ 支持单播、多播、广播；
+ 不提供可靠交付；
+ 简单。适用于很多应用，如：多媒体应用等。

TCP:
+ 面向连接的协议，提供面向连接服务；
+ 其传送的运输协议数据单元TPDU是 TCP 报文；
+ 支持点对点单播，不支持多播、广播；
+ 提供可靠服务；
+ 复杂。用于大多数应用，如：万维网、电子邮件、文件传送等。

![使用 UDP 和 TCP 的典型应用和应用层协议](/internet/5-2.png "使用 UDP 和 TCP 的典型应用和应用层协议")

+ 运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。
    1. IP 数据报要经过互连网中许多路由器的存储转发。
    2. UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。
+ TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。 

### 运输层的端口

+ 运行在计算机中的进程是用进程标识符来标志的。
+ 但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。
+ 为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。 

问题：

把一个特定机器上运行的特定程序，指明为互联网上通信的最后终点是不可行的。这是因为进程的创建和撤销都是动态的。通信的一方几乎无法识别对方机器上的进程。另外我们往往需要利用目的主机提供的功能来识别终点，而不需要知道具体实现这个功能的进程是哪一个。

解决这个问题的方法就是在运输层使用协议端口号 (protocol port number)，或通常简称为端口 (port)。
虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。

另外，软件端口与硬件端口是两个不同的概念。在协议栈层间的抽象的协议端口是软件端口。路由器或交换机上的端口是硬件端口。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。

#### TCP/IP 运输层端口

+ 端口用一个 16 位端口号进行标志，允许有65,535个不同的端口号。
+ 端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在互联网中，不同计算机的相同端口号是没有联系的。

由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的端口号（为了找到对方计算机中的应用进程） ，而且还要知道对方的 IP 地址（为了找到对方的计算机）。

#### 两大类端口

+ 服务器端使用的端口号
    1. 熟知端口，数值一般为 0 ~ 1023。
    2. 登记端口号，数值为 1024 ~ 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。
+ 客户端使用的端口号
    1. 又称为短暂端口号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。
    2. 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 

![两大类、三种类型的端口](/internet/5-3.png "两大类、三种类型的端口")
![常用的熟知端口](/internet/5-4.png "常用的熟知端口")

## 用户数据报协议 UDP 

### UDP 概述
UDP 只在 IP 的数据报服务之上增加了很少一点的功能：复用和分用的功能、差错检测的功能。其主要特点是：
1. UDP 是无连接的，发送数据之前不需要建立连接，，因此减少了开销和发送数据之前的时延。
2. UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
3. UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。
    + 发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。
    + 应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。
    + 接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。
    + 应用程序必须选择合适大小的报文。
        + 若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。
        + 若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。
4. UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 
5. UDP 支持一对一、一对多、多对一和多对多的交互通信。
6. UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。
![UDP是面向报文的](/internet/5-5.png "UDP是面向报文的")

### UDP 的首部格式
+ 用户数据报 UDP 有两个字段：数据字段和首部字段。
+ 首部字段有 8 个字节，由 4 个字段组成，每个字段都是 2 个字节。 
![UDP的首部格式](/internet/5-6.png "UDP的首部格式")

当运输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给最后的终点——应用进程。
![UDP基于端口的分用](/internet/5-7.png "UDP基于端口的分用")


![UDP的首部格式和伪首部](/internet/5-8.png "UDP的首部格式和伪首部")
在计算检验和时，临时把 12 字节的“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。

![计算校验和的例子](/internet/5-9.png "计算校验和的例子")


## 传输控制协议 TCP 概述

### TCP 最主要的特点
1. TCP 是面向连接的运输层协议。这就是说，应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接。就像应用程序在打电话，通话前先拨号建立连接，通话前要先拨号建立连接，通话结束后要挂机释放连接。
2. 每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 
3. TCP 提供可靠交付的服务。
4. TCP 提供全双工通信。
5. 面向字节流
    + TCP 中的“流”(stream) 指的是流入或流出进程的字节序列。
    + “面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流
    + TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。
    + 但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。
![面向字节流](/internet/5-10.png "面向字节流")
#### 注意
+ TCP 连接是一条虚连接而不是一条真正的物理连接。
+ TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。
+ TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。
+ TCP 可把太长的数据块划分短一些再传送。
+ TCP 也可等待积累有足够多的字节后再构成报文段发送出去。 

### TCP 的连接

+ TCP 把连接作为最基本的抽象。
+ 每一条 TCP 连接有两个端点。
+ TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字 (socket) 或插口。
+ 端口号拼接到 (contatenated with) IP 地址即构成了套接字。

![TCP的连接](/internet/5-11.png "TCP的连接")

#### TCP 连接，IP 地址，套接字
+ TCP 连接就是由协议软件所提供的一种抽象。
+ TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。
+ 同一个 IP 地址可以有多个不同的 TCP 连接。
+ 同一个端口号也可以出现在多个不同的 TCP 连接中。
+ Socket 有多种不同的意思：
    + 应用编程接口  API  称为 socket API, 简称为 socket。
    + socket API 中使用的一个函数名也叫作 socket。
    + 调用 socket 函数的端点称为 socket。
    + 调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。
    + 在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。 

## 可靠传输的工作原理
TCP 发送的报文是交给 IP 层传送的。但 IP 层提供的是不可靠的传输，因此，TCP 必须采用适当的措施才能使得两个运输层之间的通信变得可靠。
理想的传输条件有一下两个特点：一是传输信道不产生差错、二是不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。
在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。然而实际的网络都不具备以上两个理想条件。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。

### 停止等待协议
+ “停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。
+ 全双工通信的双方既是发送方也是接收方。
+ 为了讨论问题的方便，我们仅考虑 A 发送数据，而 B 接收数据并发送确认。因此 A 叫做发送方，而 B 叫做接收方。

#### 无差错情况
A 发送分组 $M_1$，发送完就暂停发送，等待 B 的确认。B 收到了 $M_1$就向 A 发送确认(ACK)。A 在收到了对 $M_1$ 的确认后，就再发送下一个分组 $M_2$。同样，在收到 B 对 $M_2$ 的确认后，再发送 $M_3$。
![无差错情况](/internet/5-12.png "无差错情况")

#### 出现差错

+ 在接收方 B 会出现两种情况：
    1. B 接收 $M_1$ 时检测出了差错，就丢弃 $M_1$，其他什么也不做（不通知 A 收到有差错的分组）。
    2. M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。
+ 在这两种情况下，B 都不会发送任何信息。
+ 但A都必须重发分组，直到B正确接收为止，这样才能实现可靠通信。

问题：A如何知道 B 是否正确收到了 M1 呢？

解决方法：**超时重传**
+ A 为每一个已发送的分组都设置了一个超时计时器。
+ A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。
+ 若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组。

问题：若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？

解决方法：**编号**
+ A 为每一个发送的分组都进行编号。若 B 收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。
+ B 为发送的确认也进行编号，指示该确认是对哪一个分组的确认。
+ A 根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。
![出现差错](/internet/5-13.png "出现差错")

#### 确认丢失和确认迟到
+ 确认丢失
    1. 若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。
    2. 假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：
        + 第一，丢弃这个重复的分组 M1，不向上层交付。
        + 第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。
+ 确认迟到
    1. 传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。
    2. A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。
    3. B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。
![确认丢失和确认迟到](/internet/5-14.png "确认丢失和确认迟到")

**注意**：在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。分组和确认分组都必须进行编号。超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。

#### 自动重传请求 ARQ
+ 通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。
+ 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。
+ 像上述的这种可靠传输协议常称为自动重传请求 ARQ  (Automatic Repeat reQuest)。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。

#### 信道利用率
停止等待协议的优点是简单，缺点是信道利用率太低。用下图来说明这个问题，为简单起见，假定在 A 和 B 之间有一条直通的信道来传送分组。
![信道利用率](/internet/5-15.png "信道利用率")
+ 可以看出，当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率就会非常低。
+ 若出现重传，则对传送有用的数据信息来说，信道的利用率就还要降低。

![耳机分割线](/line1.png "耳机分割线")
+ 为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用**流水线传输**。
+ **流水线传输**就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。
+ 由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 
![流水线传输](/internet/5-16.png "流水线传输")

### 连续 ARQ 协议
基本思想：
+ 发送方一次可以发出多个分组。
+ 使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号。
+ 每收到一个确认，发送方就把发送窗口向前滑动。
+ 接收方一般采用累积确认的方式。
+ 采用回退N（Go-Back-N）方法进行重传。
![连续ARQ协议的工作原理](/internet/5-17.png "连续ARQ协议的工作原理")

#### 累积确认
+ 接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。
+ 优点：容易实现，即使确认丢失也不必重传。
+ 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。
![累积确认](/internet/5-18.png "累积确认")

#### Go-back-N（回退 N）
+ 如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。
+ 这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。
+ 可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 
![Go-back-N](/internet/5-19.png "Go-back-N")

#### TCP 可靠通信的具体实现
+ TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。
+ TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。
+ TCP 两端的四个窗口经常处于动态变化之中。
+ TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。 

#### 滑动窗口协议
+ 滑动窗口协议比较复杂，是 TCP 协议的精髓所在。
+ 发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。
+ 连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。
