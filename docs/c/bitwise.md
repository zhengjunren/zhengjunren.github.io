# 位运算

## ~(按位取反)

`~`：此运算符为一个单目运算符，用来对一个二进制数按位取反

如：`int A = 179;`(十六进制0xb3、二进制0000000010110011)

| `A`  |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  1   |  0   |  1   |  1   |  0   |  0   |  1   |  1   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| `~A` |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  1   |  0   |  1   |  0   |  0   |  1   |  1   |  0   |  0   |



## &(按位与)

参加运算的两个数据，如果相应的二进制位都为1，则该位结果为1，否则为0.

如：`short int A = 179;  int B = 169; `

|  `A`  |  1   |  0   |  1   |  1   |  0   |  0   |  1   |  1   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  `B`  |  1   |  0   |  1   |  0   |  1   |  0   |  0   |  1   |
| `A&B` |  1   |  0   |  1   |  0   |  0   |  0   |  0   |  1   |

A&B = 161

## |(按位或)

参加运算的两个数据，如果相应的二进制位都为0，则该位结果为0，否则为1.

如：`short int A = 179;  int B = 169; `

|  `A`  |  1   |  0   |  1   |  1   |  0   |  0   |  1   |  1   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  `B`  |  1   |  0   |  1   |  0   |  1   |  0   |  0   |  1   |
| `A|B` |  1   |  0   |  1   |  1   |  1   |  0   |  1   |  1   |

A|B = 187

## ^(按位异或)

按位异或也称为XOR运算符，如果相应的二进制位不同，则该位结果为1，否则为0.

|  `A`  |  1   |  0   |  1   |  1   |  0   |  0   |  1   |  1   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  `B`  |  1   |  0   |  1   |  0   |  1   |  0   |  0   |  1   |
| `A|B` |  0   |  0   |  0   |  1   |  1   |  0   |  1   |  0   |

## <<(左移)

一般形式：`A << n;`，其中n为一个整型表达式，且大于0

如：`short int A = 27;`

把A的值向左移动n位，右边空出的n位用0补，当左移时移走的高位全都是0时相当于对A进行：A乘以2的n次方

| `A`  |  0   |  0   |  0   |  1   |  1   |  0   |  1   |  1   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| `A<<2`  |  0   |  1   |  1   |  0   |  1   |  1   |  0   |  0   |

A<<2 = 108

## >>(右移)

一般形式：`A >> n;`，其中n为一个整型表达式，且大于0

如：`unsigned short int A = 27;`

把A的值向左移动n位，右边空出的n位用0或符号位补

| `A`  |  1  |  0  |  1   |  1   |  0   |  0   |  1   |  1   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| `A>>3`  |  0   |  0  |  0  |  1  |  0  |  1  |  1  |  0  |

A>>3 = 22

> 注：
>
> 在对unsigned int 类型的无符号值进行右移位时，左边空出的部分将用0来补，在对 int 类型的有符号值进行右移时，某些机器对左边空出的部分将用符号位来填补，而有些用0来填补

## 注意事项

1. 如果两个数据不同（例如short和int型）进行位运算时（如：a&b, 而a为short，b为int型），系统首先会把它们的最低位对齐，如果a为自然数，则左边16位补满0；若a为负数，左端应补满1.如果a为无符号整型，则左侧填满0.

2. 在[移位](http://baike.baidu.com/item/移位)运算时，[short](http://baike.baidu.com/item/short)和char类型移位后的结果会变成int类型。

3. 对于short、char和int的**变量**进行**左移**时(如果是常量，则不会出现后述情况)，规定实际移动的次数是移动次数和32的余数，也就是移位33次和移位1次得到的结果相同。移动long型的数值时，规定实际移动的次数是移动次数和64的余数，也就是移动66次和移动2次得到的结果相同。