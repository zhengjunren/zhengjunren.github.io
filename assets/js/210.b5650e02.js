(window.webpackJsonp=window.webpackJsonp||[]).push([[210],{402:function(_,v,t){"use strict";t.r(v);var l=t(5),i=Object(l.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"_2017"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2017"}},[_._v("#")]),_._v(" 2017")]),_._v(" "),t("h2",{attrs:{id:"选择题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#选择题"}},[_._v("#")]),_._v(" 选择题")]),_._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[_._v("对于大型项目而言，实现不能完整清晰地定义需求是常事，需要开发内容逐步丰富原型，这是可以采用那种模型（D)")])]),_._v(" "),t("p",[_._v("A. 瀑布模型")]),_._v(" "),t("p",[_._v("B. 演化模型")]),_._v(" "),t("p",[_._v("C. 喷泉模型")]),_._v(" "),t("p",[_._v("D. 螺旋模型")]),_._v(" "),t("p",[_._v("瀑布模型、迭代模型和快速原型开发是典型的三个产品生命周期模型。")]),_._v(" "),t("ul",[t("li",[_._v("对需求清晰、在项目初期就可以明确所有需求、不需要二次开发的项目而言，瀑布模型适合用来作产品的生命周期模型。")]),_._v(" "),t("li",[_._v("对于事先不能完整定义产品所有需求、计划多期开发的项目来说，迭代模型适合用来作产品的生命周期模型。")]),_._v(" "),t("li",[_._v("对于需要很快给客户/用户演示产品原型的项目，快速原型开发适用于作产品的生命周期模型。")])]),_._v(" "),t("ol",{attrs:{start:"9"}},[t("li",[_._v("下列那种不属于常见软件领域的模式种类（D)")])]),_._v(" "),t("p",[_._v("A. 过程模式")]),_._v(" "),t("p",[_._v("B. 架构风格")]),_._v(" "),t("p",[_._v("C. 设计模式")]),_._v(" "),t("p",[_._v("D. 文档模板")]),_._v(" "),t("ol",{attrs:{start:"14"}},[t("li",[_._v("下列哪一项不是系统测试的内容（D)")])]),_._v(" "),t("p",[_._v("A. 功能测试")]),_._v(" "),t("p",[_._v("B. 恢复测试")]),_._v(" "),t("p",[_._v("C. 回归测试")]),_._v(" "),t("p",[_._v("D. 模块接口测试")]),_._v(" "),t("p",[_._v("软件测试按四个步骤进行，即单元测试、组装测试、确认测试和系统测试。")]),_._v(" "),t("p",[_._v("单元测试的内容有：模块接口测试、局部数据结构测试、路径测试、错误处理测试、边界测试")]),_._v(" "),t("p",[_._v("组装测试的方式有一次性组装方式和增殖式组装方式")]),_._v(" "),t("p",[_._v("确认有黑盒测试、软件配置复查、α测试和β测试、验收测试、确认测试的结果")]),_._v(" "),t("p",[_._v("系统测试有功能测试、回归测试、可靠性测试、强度测试、性能测试、恢复测试、启动/关机测试、配置测试、安全性测试、可使用性测试、可支持性测试、安装测试、互连测试、兼容性测试、容量测试、文档测试")]),_._v(" "),t("ol",{attrs:{start:"15"}},[t("li",[_._v("在软件项目估算中，工作量的计量单位通常为（A）")])]),_._v(" "),t("p",[_._v("A. 人月")]),_._v(" "),t("p",[_._v("B. KLOC")]),_._v(" "),t("p",[_._v("C. KLOC/人月")]),_._v(" "),t("p",[_._v("D. 元/人")]),_._v(" "),t("p",[_._v("工作量的单位为 人月，生产率的单位为 KLOC/人月")]),_._v(" "),t("ol",{attrs:{start:"18"}},[t("li",[_._v("UML 模型中的事务包括（D)")])]),_._v(" "),t("p",[_._v("A. 结构事务")]),_._v(" "),t("p",[_._v("B. 分组事务")]),_._v(" "),t("p",[_._v("C. 行为事务")]),_._v(" "),t("p",[_._v("D. 以上都对")]),_._v(" "),t("ol",{attrs:{start:"19"}},[t("li",[_._v("需求工程通常包括两方面内容，他们是（A）")])]),_._v(" "),t("p",[_._v("A. 需求开发和需求管理")]),_._v(" "),t("p",[_._v("B. 需求开发和需求分析")]),_._v(" "),t("p",[_._v("C. 需求管理和需求定义")]),_._v(" "),t("p",[_._v("D. 需求分析和需求管理")]),_._v(" "),t("p",[_._v("需求工程包括")]),_._v(" "),t("p",[t("img",{attrs:{src:"F:%5C%E5%93%88%E5%93%88%E5%93%88%5Czhengjunren.github.io%5Cdocs.vuepress%5Cpublic%5Csoft_engineering%5Cimage-20210310134202472.png",alt:"image-20210310134202472"}})]),_._v(" "),t("h2",{attrs:{id:"简答题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简答题"}},[_._v("#")]),_._v(" 简答题")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("请简述 CMM 帮助软件企业进行过程改进的基本方法。")]),_._v(" "),t("ul",[t("li",[_._v("CMM 是对于软件组织在定义、实施、度量、控制和改善其软件过程的实践中各个发展阶段的描述。对软件过程的改进，是在完后才能一个又一个小的改进步骤基础上不断进行的渐进过程，而不是一蹴而就的彻底革命。CMM 把软件过程从无序到有序的进化过程分为 5 个阶段，并把这些阶级排序，形成 5 个逐层提高的等级。")])])]),_._v(" "),t("li",[t("strong",[_._v("请简述增量开发模型与迭代开发的异同点。")]),_._v(" "),t("ul",[t("li",[_._v("增量开发模型与迭代开发模型都属于软件生命周期模型。增量开发模型是从功能量上来划分的，每阶段完成一定的功能，适用于需求比较明确，架构比较稳定的软件开发；")]),_._v(" "),t("li",[_._v("迭代开发模型是从深度或细化的程度来划分的，每阶段功能得到完善、增强、适用于需求不甚明确，难度比较大的软件开发。")])])]),_._v(" "),t("li",[t("strong",[_._v("为什么应用软件开发和软件工程方法解决大规模、复杂问题时，软件系统的质量和效率无法得到保证？应该如何解决？")]),_._v(" "),t("ul",[t("li",[_._v("原因：大规模复杂软件系统的性能与质量对软件工程技术提出了新的要求。在非功能性需求方面：①系统性能要求，可用性要求②系统可适用性和可移植性要求③系统可靠性和保密性要求④系统可重用性要去")]),_._v(" "),t("li",[_._v("解决方法：在系统的局部算法结构之前，着重进行系统的整体结构设计。")])])]),_._v(" "),t("li",[t("strong",[_._v("请简述面向对象设计与结构化设计有何异同？")]),_._v(" "),t("ul",[t("li",[_._v("面向对象设计与结构化设计都属于软件工程方法。结构化设计采用结构化技术来完成软件开发的各项任务。这种方法学把软件生命周期全过程依次划分为若干个阶段，然后顺序地逐步完后才能每个阶段的任务。没一个阶段的开始和结束都有严格的标准，对于任何两个相邻的阶段而言，前一个阶段的结束标准就是后一个阶段的开始标准。其主要缺点是在适应变化方面不够灵活。另外结构化设计要么面向行为，要么面向数据，缺乏使两者有机结合的机制")]),_._v(" "),t("li",[_._v("面向对象设计把数据和行为看成同等重要，它是将数据和对数据的操作紧密地结合起来的方法，这是面向对象设计方法与结构化设计方法的重要区别。")])])]),_._v(" "),t("li",[t("strong",[_._v("请简要介绍白盒测试中逻辑覆盖主要分成了哪几种测试覆盖，它们的含义分别是什么？")]),_._v(" "),t("ul",[t("li",[_._v("语句覆盖：设计足够的用例，使每个可执行的语句至少执行一次")]),_._v(" "),t("li",[_._v("判定覆盖：设计足够的用例，在每个可执行的语句至少执行一次的情况下，每个真假分支至少执行一次")]),_._v(" "),t("li",[_._v("条件覆盖：设计足够的用例，在每个可执行的语句至少执行一次的情况下，使得程序中每个判断的每个条件的可能取值至少执行一次")]),_._v(" "),t("li",[_._v("判定-条件覆盖：设计足够的用例，使判断中每个条件的所有可能取值至少执行一次，同时每个判断本身所有可能结果也至少执行一次")]),_._v(" "),t("li",[_._v("条件-组合判断：使得每个判定中条件的各种可能组合都至少出现一次")]),_._v(" "),t("li",[_._v("路径覆盖：设计足够测试用例，覆盖程序中所有可能的路径")])])]),_._v(" "),t("li",[t("strong",[_._v("请简述 UML 时序图的含义、组成元素和工作机制。")]),_._v(" "),t("ul",[t("li",[_._v("时序图描述对象之间的动态交互关系，着重表现对象间消息传递的时间顺序")]),_._v(" "),t("li",[_._v("组成元素：参与者、对象、对象的生命线、消息")]),_._v(" "),t("li",[_._v("工作机制：在时序图中，纵轴从上到下表示时间顺序；横轴从左到右安排有关联的各个相关对象，关系密切的对象应该安排在相邻位置。每个对象下面有条称为生命线的竖直虚线，绘制在生命线中的细长矩形符合表示该对象的生存活跃期，虚线为该对象的休眠期。对象之间的消息传递由实箭线表示，箭头上标记消息的名称，箭头从发送方向接收方。")])])])])])}),[],!1,null,null,null);v.default=i.exports}}]);