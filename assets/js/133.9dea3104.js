(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{706:function(l,v,_){"use strict";_.r(v);var a=_(7),i=Object(a.a)({},(function(){var l=this,v=l.$createElement,_=l._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[_("h2",{attrs:{id:"final"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#final"}},[l._v("#")]),l._v(" final")]),l._v(" "),_("ol",[_("li",[_("p",[l._v("当"),_("code",[l._v("final")]),l._v("修饰一个类时，表示这个类不能被继承。注意：")]),l._v(" "),_("ul",[_("li",[l._v("被"),_("code",[l._v("final")]),l._v("修饰的类，"),_("code",[l._v("final")]),l._v("类中的成员变量可以根据自己的实际需要设计为"),_("code",[l._v("final")]),l._v("。")]),l._v(" "),_("li",[_("code",[l._v("final")]),l._v("类中的成员方法都会被隐式的指定为final方法。")])])]),l._v(" "),_("li",[_("p",[l._v("当"),_("code",[l._v("final")]),l._v("修饰方法时，表示这个方法不能被重写。")])]),l._v(" "),_("li",[_("p",[l._v("当"),_("code",[l._v("final")]),l._v("修饰成员变量时，注意：")]),l._v(" "),_("ul",[_("li",[l._v("必须要赋初始化值，而且只能初始化一次。赋值方式：直接赋值、在构造函数中赋值。")]),l._v(" "),_("li",[l._v("当修饰的成员变量是基本数据类型，则表示这个变量值不能改变。")]),l._v(" "),_("li",[l._v("当修饰的成员变量是一个引用类型，则是说这个引用的地址的值不能修改，但是这个引用所指向的对象里面的内容还是可以改变的。")])])])]),l._v(" "),_("h2",{attrs:{id:"finally"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#finally"}},[l._v("#")]),l._v(" finally")]),l._v(" "),_("p",[_("code",[l._v("finally")]),l._v("关键字用于"),_("code",[l._v("try")]),l._v("后面，"),_("code",[l._v("finally")]),l._v("块中的代码总是执行，不论是否发生异常。一般用于清理工作、关闭链接等类型的语句。")]),l._v(" "),_("h2",{attrs:{id:"finalize"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#finalize"}},[l._v("#")]),l._v(" finalize")]),l._v(" "),_("p",[l._v("是"),_("code",[l._v("Object")]),l._v("类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等，JVM不保证此方法总被调用。")])])}),[],!1,null,null,null);v.default=i.exports}}]);