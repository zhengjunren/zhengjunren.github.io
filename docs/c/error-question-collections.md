# 错题集合
## 选择
1. **已定义一下函数：该函数的返回值是：( C )<br/>**
A. 不确定的值　　　B. 形参 p 中存放的值　　　C. 形参 p 所指存储单元中的值　　　D. 形参 p 的地址值

```c
fun (int *p) {
    return *p;
}
```

2. **用 c 语言编写的代码程序（B）<br/>**
A. 可立即执行　　　B. 是一个源程序　　　C. 经过编译即可执行　　　D. 经过编译解释即可执行<br/>

解释：C语言是一种高级语言，C语言源程序经过C语言编译程序编译之后，生成一个后缀为．OBJ的二进制文件(称为目标文件)，最后还要由称为“连接程序”(Link)的软件，把此．OBJ文件与c语言提供的各种库函数连接在一起，生成一个后缀． EXE的可执行文件。显然C语言不能立即执行。

3. **以下不合法的字符常量是（A）<br/>**
A. '\018'　　　B. '\"'　　　C. '\\'　　　D. '\xcc'

每个字符常量都对应一个整数编码，所以表示一个字符有两种方式：
一、直接写出字符本身，然后用一对单引号括起来。比如'A'，'1'等等。但是有一些特殊字符不能这样表示，比如单引号本身，不能写成 '''，会报错，所以给这些特殊字符前面加个“\”符号标志一下，告诉编译器接下来的字符要当成普通字符来读，就像这样'\''。
二、用编码表示字符。就像用9527叫周星弛一样。具体做法是先写个斜杠，再加上编码，最后用单引号括起来。字符的编码是什么？查ASCII码表。注意这里的编码只能用八进制和十六进制，用八进制时前面加0或不加，用十六进制时前面加x。 比如'\07'和'\7'是一样的，是八进制。'\x7'是十六进制。
你的问题里 A、D是第二种表示方法，B、C是第一种表示方法，形式都没错，只有A里使用了八进制编码，就不应该出现8这个数字，所以A错了。

4. **有以下定义语句`double a, b; int w; long c;` 若各变量已正确赋值，则下列选项中正确的表达式是（C）<br/>**
A. `a=a+b=b++`　　　B. `w%((int)a+b)`　　　C. (c+w)%(int)a　　　D. w=a==b;<br/>

解：D选项是语句不是表达式

5. **已有定义：`int x = 3, y = 4, z = 5;`，则表达式`!(x+y)+z-1&&y+z/2`的值为（D）<br/>**
A. 6　　　B. 0　　　C. 2　　　D. 1<br/>

解：该表达式等价于`(!(x+y)+z-1)&&(y+z/2)`

6. **有以下程序，程序输出为（D）**
```c
#include <stdio.h>

int main() {
    int a = 0, b = 0, c = 0, d = 0;
    if (a = 1) b = 1; c = 2;
    else d = 3;
    printf("%d, %d, %d, %d", a, b, c, d);
    return 0;
}
```
A. 0,1,2,0　　　B. 0,0,0,3　　　C. 1,1,2,0　　　D. 编译出错<br/>

解：if 语句的 c=2; 将 if-else 分开，编译出错

7. **在赋值语句中通过赋值运算符“=”对字符型数组进行整体赋值.如题,下列描述中不正确的是（D）<br/>**
A、字符型数组中可能存放字符串<br/>
B、可以对字符型数组进行整体输入、输出<br/>
C、可以对整型数组进行整体输入、输出<br/>
D、不能在赋值语句中通过赋值运算符“=”对字符型数组进行整体赋值<br/>

也许这个题不是这个意思,请注意赋值表达式的一般形式为：
变量 赋值运算符 表达式； （见《C语言程序 第三版 谭浩强》第63页）
而一楼的 char a[] = "abc"虽然合法,但却不能算是赋值表达式,而是字符数组的初始化.而 a[] = "abc"却是不合法的赋值表达式,那是不是可以说“不能在赋值语句中通过赋值运算符“=”对字符型数组进行整体赋值”是对的呢?如果要咬文嚼字的话,我到觉得像一楼说的那样,那个“整体赋值”有问题!关键是问题在哪儿呢?

8. **下列说法错误的是（C）<br/>**
A. 在 C 中，函数中的自动变量可以赋初值，每调用一次，赋一次初值<br/>
B. 在 C 中，在调用函数时，实际参数和对应的形参在类型上只需要值兼容<br/>
C. 在 C 中，外部变量的隐含类别是自动存储类别<br/>
D. 在 C 中，函数形参可以说明为 register 变量<br/>

函数的形参不bai仅可以用auto或者register来说明，du因为函数的形参还可以用const来定义一个其值不可变的常量形参，还可以在main函数前定义一个结构体，然后用结构体名来定义函数的形参。

外部变量的隐含类别是外部存储类别，即extern

函数中的变量赋初值则每次调用都将会赋初值，如果想在第一次调用是赋一次初值，而在其后的调用过程中在第一次调用的基础上继续进行运算，则可以定义static静态变量并且直接赋予初值。

在调用函数时，实参和对应的形参在类型上只需赋值兼容。因为在计算机内部，像字符型或者各类符号（中文，法文，德文等等）都是以ASCII码值的形式存在，因此当对字符进行操作的时候同样可以通过四则运算来达成有关目的，只需知道对应的码值就可以了，所以只需赋值兼容都可以操作。<br/>

9. **以下关于函数的叙述中正确的是（B）<br/>**
A. 每个函数都可以被其他函数调用（包括 main 函数）<br/>
B. 每个函数都可以被单独编译<br/>
C. 每个函数都可以单独运行<br/>
D. 在一个函数内部可以定义另一个函数

A、main函数是不能被任何函数调用的,C语言中，除了主函数外，用户定义的函数或库函数都可以互相进行调用，甚至可以自己调用自己。所以a错了<br/>
B、函数可以单独编译,每个函数都能单独写成一个文件,所以B对的<br/>
C、函数都要通过main函数的调用才能正确的运行,main函数是一个程序的唯一入口<br/>
D、函数是不可以嵌套使用的

10. **以下函数值的返回类型是（A）<br/>**
A. int　　　B. 不确定　　　C. void　　　D. float
```c
fun (float x){
    float y;
    y = 3*x - 4;
    return y;
}
```
C语言中如果函数前不加任何数据类型时，默认函数的类型为整型，函数的类型就是函数返回值的类型

11. **若已定义的函数有返回值，则以下关于该函数调用的叙述中错误的是（D）<br/>**
A. 函数调用可以作为独立的语句存在<br/>
B. 函数调用可以作为一个函数的实参<br/>
C. 函数调用可以出现在表达式中<br/>
D. 函数调用可以作为一个函数的形参

C语言函数的参数会出现在两个地方，分别是函数定义处和函数调用处，这两个地方的参数是有区别的。
**形参（形式参数）**
在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参。

**实参（实际参数）**
函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参。

形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。

12. **以下不能正确进行字符串赋初值的语句是（A）<br/>**
A．char str[5]= "good!";<br/>
B．char str[]= "good!";<br/>
C．char *str= "good!";<br/>
D．char str[5]= {'g', 'o', 'o', 'd'};<br/>

[解析]选项A定义了一个字符数组str，具有5个元素，但赋初值的时候，初值个数却是6个(有一个'\0'，)；<br/>
选项B定义了一个字符数组str并给它赋初值，由于省去了长度定义，长度由初值个数确定，相当于str[6]；<br/>
选项C定义了一个字符型指针变量并用一个字符串给它赋初值，使该字符型指针指向了该字符串；<br/>
选项D是对字符型数组中单个元素依次赋初值。

13. **以下叙述中错误的是(D)。<br/>**
A．二进制文件打开后可以先读文件的末尾，而顺序文件不可以<br/>
B．在程序结束时，应当用fclose函数关闭已打开的文件<br/>
C．在利用fread函数从二进制文件中读数据时，可以用数组名给数组中所有元素读入数据<br/>
D．不可以用FILE定义指向二进制文件的文件指针

[解析] 顺序文件只能从头读写，二进制文件可以随机读写，选项A正确；<br/>
文件在使用后应关闭，当程序结束时，应当把打开的文件关闭，选项B正确；<br/>
用fread()函数可以一次性地读取同类型的很多数据，选项C正确；<br/>
在C语言中指向各种文件的文件指针都是通过FILE来定义的，故选项D是错误的。所以4个选项中选D

14. **以下叙述中不正确的是(D)<br/>**
A．C语言中的文本文件以ASCII码形式存储数据<br/>
B．C语言中对二进制文件的访问速度比文本文件快<br/>
C．C语言中，随机读写方式不适用于文本文件<br/>
D．C语言中，顺序读写方式不适用于二进制文件

[解析]在C语言中文本文件是以ASCII码形式存放的，每个字符占一个字节。由于数据在计算机中是以二进制形式存放的，因此二进制文件中的数据可以直接读出，而不需要像文本文件那样把ASCII码转换成二进制，因此速度较快。在文本文件中，数据以ASCII码形式存放的，用户很难判定一个数据到底占几个字节，所以不适合使用随机读写方式。

15. **下列程序执行后数出的结果是（A）<br/>**
A. 6, 6, 6.0, 6.0　　　B. 6, 6, 6.7, 6.7　　　C. 6, 6, 6.0, 6.7　　　D. 6, 6, 6.7, 6.0<br/>
```c
int main() {
    double d;float f;long l;int i;
    i = f = l = d = 20 / 3;
    printf("%d, %ld, %.1f, %.1f", i, l, f, d);
    return 0;
}
```
[解析] 20/3 是整型变量相除，结果为6，再赋值给变量 d

16. **在 C 语言中，下列说法正确的是：（D）<br/>**
A. do-while 语句构成的循环不能用其他语句构成的循环代替<br/>
B. "do 语句 while(条件)" 的循环必须使用 "break" 语句退出循环<br/>
C. "do 语句 while(条件)" 的循环中，当条件为非 0 时结束循环<br/>
D. "do 语句 while(条件)" 的循环中，当条件为 0 时结束循环

[解析]
```c
int flag = 1, x = 0;
while(flag || x < 10);{
    if(flag == 1) {
        flag = 0;
    }
    x++;
}
int x = 0;
do {
    x++
} while(x < 10);
```

17. 宏定义`#define G 9.8`中宏名 G 代表（C）
A. 一个单精度实数　　　B. 一个双精度实数　　　C. 一个字符串　　　D. 不确定类型的实数

[解析]不带参数的宏定义是指用一个指定的标识符来代表一个字符串

18. **在C语言中，二维数组元素在内存中的存放顺序是（A）<br/>**
A. 按行存放　　　　B. 按列存放　　　　C. 由用户自己定义　　　　D. 由编译器决定

[解释]二维数组在内存中按行存放。<br/>
二维数组在c语言中的定义为：int a[x][y]。具体理解为二专维数组a，有x行数据，每行数据有属y个。

解释：当我们在进行数据的存取时，在无x的条件下不可能取出值。但是在没有y的条件下，可以通过地址取出x行的某个值。
当我们知道x的值，代表我们能确定这一行的首地址，因为二维数组按照行存放，所以第x行的数据地址关系排列递增的。

反证法：如果二维数组按列存放，则我们知道y值，可以确定首地址的值，去进行值得存取。显然由于C语言不支持这样的方式，所以C语言中二维数组按照行存放。

19. **若执行 fopen() 函数时发生错误，则函数的返回值是（B）<br/>**
A. 地址值　　　　B. 0　　　　C. 1　　　　D. EOF

[解释]若执行fopen函数时发生错误，则函数的返回值是NULL（即0）。
文件顺利打开后，指向该流的文件指针就会被返回。若果文件打开失败则返回NULL，并把错误代码存在errno 中。

20. **若程序中有下面的说明和定义，则会发生的情况是（A）<br/>**
A. 编译出错<br/>
B. 程序将顺利编译、连接、执行<br/>
C. 能顺利通过编译、连接，但不能执行<br/>
D. 能顺利通过编译，但连接出错
```c
struct abc
   {
       int x;
       char y;
   }
   struct abc s1,s2;
```
[解析]声明结构体要带分号