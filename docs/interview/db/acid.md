---
title: ACID
date: 2021-01-25
---

## 原子性A

事务是访问和更新数据库的程序执行单元，事务中可能包含一个或多个 SQL 语句，这些语句要么都执行，要么都不执行

1. 开始事务
2. 执行 SQL 语句
3. 提交事务

如果事务中的一个 SQL 语句失败了，那么这个事务中的已经执行的 SQL 语句就要回滚，回滚到事务之前的状态

### 原理

undo.log日志会记录事务执行的 SQL，当事务需要回滚时，通过反向补偿回滚数据库状态

比如执行了一个 insert 操作，回滚时执行一个相反的操作即 delete，对于 update，回滚时会执行一个相反的update，把数据再改回去

### 持久性

持久性是指这个事务一旦提交，对数据库的改变就是永久性的

### 原理

MySQL 的数据时存在磁盘中的，但如果每次读数据都需要经过磁盘 I/O，那么效率会很低。所以 Innodb 提供了一个缓存 buffer ，该 buffer 包含磁盘中的部分数据页的映射，作为访问数据库的缓存；当从数据库读取数据时，会从 buffer 中获取，如果 buffer 中没有，就从磁盘中读取，读取完之后再放到缓存之中，当向数据库中写入数据的时候，会先向缓存中写入数据，定期将缓存中的数据刷新至磁盘，进行持久化。此时存在一个问题：虽然读取效率提升，但也增加了数据丢失的风险，如果 buffer 中的数据没有来得及同步到磁盘上，此时 MySQL 又宕机了，那么 buffer 中的数据就会丢失，进而造成数据丢失，不能保证事务的持久性。

redo.log 预写式日志：将所有的修改写入到日志中，在更新到 buffer 中

当数据库的数据要进行新增和修改时，除了修改 buffer 中的数据，还要把这次的操作记录到 redo.log

既然 redo.log 也需要把事务提交的日志写入至磁盘，那为什么比直接将 buffer中的数据写入磁盘中要快呢？

1. buffer 中的数据持久化是随机写的 I/O ，每次修改的数据位置都是随机的，但 redo.log 是追加的
2. buffer 持久化数据是以数据页 page 为单位的，MySQL 默认的配置页大小是 16 KB，一个数据页上的一个小小的修改都要把整页数据写入，而 redo.log 只需要写入这个真正需要的部分，无效的 I/O 大大减少了

## 隔离性

