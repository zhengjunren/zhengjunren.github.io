(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{721:function(t,e,r){"use strict";r.r(e);var a=r(7),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"原子性a"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原子性a"}},[t._v("#")]),t._v(" 原子性A")]),t._v(" "),r("p",[t._v("事务是访问和更新数据库的程序执行单元，事务中可能包含一个或多个 SQL 语句，这些语句要么都执行，要么都不执行")]),t._v(" "),r("ol",[r("li",[t._v("开始事务")]),t._v(" "),r("li",[t._v("执行 SQL 语句")]),t._v(" "),r("li",[t._v("提交事务")])]),t._v(" "),r("p",[t._v("如果事务中的一个 SQL 语句失败了，那么这个事务中的已经执行的 SQL 语句就要回滚，回滚到事务之前的状态")]),t._v(" "),r("h3",{attrs:{id:"原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),r("p",[t._v("undo.log日志会记录事务执行的 SQL，当事务需要回滚时，通过反向补偿回滚数据库状态")]),t._v(" "),r("p",[t._v("比如执行了一个 insert 操作，回滚时执行一个相反的操作即 delete，对于 update，回滚时会执行一个相反的update，把数据再改回去")]),t._v(" "),r("h3",{attrs:{id:"持久性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#持久性"}},[t._v("#")]),t._v(" 持久性")]),t._v(" "),r("p",[t._v("持久性是指这个事务一旦提交，对数据库的改变就是永久性的")]),t._v(" "),r("h3",{attrs:{id:"原理-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理-2"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),r("p",[t._v("MySQL 的数据时存在磁盘中的，但如果每次读数据都需要经过磁盘 I/O，那么效率会很低。所以 Innodb 提供了一个缓存 buffer ，该 buffer 包含磁盘中的部分数据页的映射，作为访问数据库的缓存；当从数据库读取数据时，会从 buffer 中获取，如果 buffer 中没有，就从磁盘中读取，读取完之后再放到缓存之中，当向数据库中写入数据的时候，会先向缓存中写入数据，定期将缓存中的数据刷新至磁盘，进行持久化。此时存在一个问题：虽然读取效率提升，但也增加了数据丢失的风险，如果 buffer 中的数据没有来得及同步到磁盘上，此时 MySQL 又宕机了，那么 buffer 中的数据就会丢失，进而造成数据丢失，不能保证事务的持久性。")]),t._v(" "),r("p",[t._v("redo.log 预写式日志：将所有的修改写入到日志中，在更新到 buffer 中")]),t._v(" "),r("p",[t._v("当数据库的数据要进行新增和修改时，除了修改 buffer 中的数据，还要把这次的操作记录到 redo.log")]),t._v(" "),r("p",[t._v("既然 redo.log 也需要把事务提交的日志写入至磁盘，那为什么比直接将 buffer中的数据写入磁盘中要快呢？")]),t._v(" "),r("ol",[r("li",[t._v("buffer 中的数据持久化是随机写的 I/O ，每次修改的数据位置都是随机的，但 redo.log 是追加的")]),t._v(" "),r("li",[t._v("buffer 持久化数据是以数据页 page 为单位的，MySQL 默认的配置页大小是 16 KB，一个数据页上的一个小小的修改都要把整页数据写入，而 redo.log 只需要写入这个真正需要的部分，无效的 I/O 大大减少了")])]),t._v(" "),r("h2",{attrs:{id:"隔离性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#隔离性"}},[t._v("#")]),t._v(" 隔离性")])])}),[],!1,null,null,null);e.default=v.exports}}]);