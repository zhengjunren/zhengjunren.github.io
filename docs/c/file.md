# 文件
## 文件分类
1. 程序文件，这种文件的内容是程序代码。如源程序文件，目标文件，可执行文件等
2. 数据文件，其内容不是程序，而是供程序运行时读写的数据。
> 注：
> 1. 所谓“文件”一般指存储在外部介质（如磁盘）上数据的集合。
> 2. 终端即计算机的各种输入输出设备。操作系统把终端都统一作为文件来处理。例如：终端键盘是输入文件，显示屏和打印机是输出文件。

一个文件要有唯一的文件标识，以便用户识别和引用。文件标识包括3部分：
①文件路径②文件名主干③文件后缀 如：
```
E:\C程序设计\源程序 \ helloworld.cpp
     ↓                  ↓        ↓
文件路径           文件名主干    文件后缀
```
> 注：文件标识常被称为文件名，而不仅是文件名主干。

## 数据文件
1. 分类：ASCII文件（文本文件）和二进制文件（镜像文件）。存取一个二进制文件不需要转换，存取一个文本文件需转换。比如把整数16分别以二进制和文本文件的形式存放

> 注：
> 1. 在windows系统中，文本模式下，文件以"\r\n"代表换行。若以文本模式打开文件，并用fputs等函数写入换行符"\n"时，函数会自动在"\n"前面加上"\r"。即实际写入文件的是"\r\n" 。
> 2. 在类Unix/Linux系统中文本模式下，文件以"\n"代表换行。所以Linux系统中在文本模式和二进制模式下并无区别。

```c
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
	FILE * p = fopen("D:\\81.txt", "rb");		//打开方式为r时，输出3个ASCII码值，如果打开方式为rb，输出4个ASCII码值
	if(p == NULL)
	{
		printf("文件打开失败，程序退出\n");
		exit(-1);
	}
	char ch;
	while((ch = fgetc(p)) != EOF)
		printf("%d\n", ch);
	fclose(p);
	return 0;
}
/*
在Windows系统下，使用fputc,fputs,fprintf向一个文件写入数据时，如果写入'\n',文件的打开方式为文本模式，实际写入的是'\r'和'\n'两个字符；
如果文件的打开方式为二进制模式，实际就是写入一个'\n'字符
使用fgetc，fgets，fscanf向一个文件读入数据时，如果读到'\r'和'\n'，而且文件打开方式为文本模式的话，会把这两个字符当成一个'\n'读进来；
如果文件的打开方式为二进制模式，那么不会发生这种转换，读进来的就是'\r'和'\n'两个字符

建议：如果文件本身是一个文本文件，就用文件模式的文件使用方式打开，对这个文件进行读写就用这6个处理字符或者字符串的函数进行读写。
*/
```
81.txt:
```
A
B
```

2. 数据从源到目的端的流动称为数据流
3. 数据流按读写数据的类型之不同分为两种：字节流和字符流。两者的区别就是读写的时候一个是按字节读写，一个是按字符。
按照源和目的端的不同可分为：输入流，输出流和缓冲流
## 文件缓冲区
C90采用“缓冲文件系统”处理数据文件，所谓缓冲文件系统是指系统自动地在内存区为程序中一些正在使用的文件开辟一个文件缓冲区。比如：从内存向磁盘输出数据可能会先送到内存中的缓冲区，装满缓冲区或者缓冲区被刷新后才一起送到磁盘去。

## 文件类型指针
1. 每个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件的有关信息（如文件的名字，文件状态及文件当前位置等）。这些信息是保存在一个结构体变量中。该结构体类型是由系统声明的，取名为FILE（在stdio.h中声明）。
2. 我们可以定义一个FILE类型的指针，然后使该指针指向某一个文件的文件信息区，那么我们就可以访问这个文件了。



## 打开文件

1. 打开是指为文件**建立相应的信息区和文件缓冲区。**

2. 使用`fopen`打开文件，`fopen`的调用方式为：`fopen（文件名，使用文件方式）;`

> 如：`FILE fp = fopen(“a1”, “r”);`

打开名字为`a1`的文件，使用文件方式“读入”（r代表read，即读入），其函数返回值是指向a1文件的指针（即a1文件信息区的开头地址），那么通过`fp`我们就可以访问这个文件。

| 文件使用方式  | 含义                                   | 如果指定文件不存在 |
| :-----------: | :------------------------------------- | :----------------: |
|  `r`（只读）  | 为了输入数据，打开一个已存在的文本文件 |        报错        |
|  `w`（只写）  | 为了输出数据，打开一个文本文件         |     创建新文件     |
|  `a`（追加）  | 向文件尾添加数据                       |     创建新文件     |
| `rb`（只读）  | 为了输入数据，打开一个二进制文件       |        报错        |
| `wb`（只写）  | 为了输出数据，打开一个二进制文件       |     创建新文件     |
| `ab`（追加）  | 向二进制文件尾添加数据                 |     创建新文件     |
| `r+`（读写）  | 为了读和写，打开一个文本文件           |        出错        |
| `w+`（读写）  | 为了读和写，新建一个文本文件           |     创建新文件     |
| `a+`（读写）  | 为了读和写，打开一个文本文件           |     创建新文件     |
| `rb+`（读写） | 为了读和写，打开一个二进制文件         |        报错        |
| `wb+`（读写） | 为了读和写，新建的二进制文件           |     创建新文件     |
| `ab+`（读写） | 为了读和写，打开一个二进制文件         |     创建新文件     |

> 注意：
>
> 1. 不带b，操作的是文本文件，带b操作的是二进制文件；带+是读写；如果指定文件不存在，只有带r的才会出错。
> 2. 带w的，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
> 3. 对一个文件进行读或写，读到或者写到哪一个位置上，是通过“文件位置标记”实现的。随着我们对文件的读写操作，文件位置标记会自动移动。
> 4. 带r和带w的，文件位置标记都是在文件的开头位置；如果我们想对一个文件添加数据，就使用带a的，文件位置标记会在文件的末尾位置。
> 5. 如果`fopen`不能实现“打开”的任务，其返回值为`NULL`。
> 6. 有的c编译系统可能不能完全提供上述表格的功能，有的也不用`r+`,`w+`,`a+`而用`rw`,`wr`,`ar`等
>    1. 程序中可以使用3个标准流文件——标准输入流、标准输出流、标准出错输出流。系统对这3个文件指定了与终端的对应关系。**标准输入流是从终端的输入，标准输出流是向终端的输出，标准出错输出流是当程序出错时将出错信息发送到终端。**我们编写程序时，不需要使用`fopen`打开这3个文件，**程序开始运行时会自动打开**。系统定义了3个**文件指针**`stdin`，`stdout`，`stderr`分别指向标准输入流、标准输出流、标准出错输出流。

## 关闭文件

1. 关闭是指**撤销文件信息区和文件缓冲区。**

2. 使用**fclose****（文件指针）**关闭数据文件。其作用就是关闭**文件指针**所指向的文件。

> 注：
>
> 1. **如果不关闭文件将会丢失数据**：比如当我们向文件写数据时，缓冲区未充满而程序结束，就有可能使缓冲区中的数据丢失。而使用fclose函数关闭文件，会先把缓冲区中的数据输出到磁盘，然后才撤销文件信息区。
> 2. `flose`成功的执行了关闭操作返回0，否则返回EOF（-1）。


## fgetc&fputc
`int fgetc(FILE *stream)`:

从指定的流 `stream` 获取下一个字符（一个无符号字符），并把位置标识符往前移动。
取出错返回EOF（-1）

`int fputc(int char, FILE *stream)`:

把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。
输出失败返回EOF（-1）

```c
#include <stdio.h>
#include <stdlib.h>
int main(void) {
    char name[50] =
        "G:\\codeOfc\\file\\古诗.txt"; // char name[50] = "G:/codeOfc/file/古诗.txt";等价
    FILE *fp = fopen(name, "r");
    if (fp == NULL) {
        printf("文件打开失败，程序退出\n");
        exit(-1);
    }
    FILE *fp2 = fopen("G:\\codeOfc\\file\\古诗2.txt", "w");
    if (fp2 == NULL) {
        printf("文件打开失败，程序退出\n");
        exit(-1);
    }
    char ch;
    while ((ch = fgetc(fp)) != EOF)
        fputc(ch, fp2);
    fclose(fp);
    fclose(fp2);
    return 0;
}
```
>  注：
>
> 1. `fp`所指向的文件打开时的使用方式为文本文件或者二进制文件都可以
> 2. C系统把`fputc`和`fgetc`函数定义为宏名`putc`和`getc`：
>    + `#define putc(ch, fp) fputc(ch, fp)`
>    + `#define getc(fp) fgetc(fp)`
> 3. 所以说`putc`和`fputc`，`getc`和`fgetc`的作用是一样的。

## fgets&fputs

`fgets(str, n, fp)`：

一次最多从fp指向的文件读入`(n-1)`个字符，最后自动加`'\0'`存放到字符数组`str`中；如果在读完`(n-1)`个字符之前，遇到`'\n'`或者文件结束符`EOF`，读入结束，将所读字符，加`'\0'`存放到字符数组`str`中。读成功返回地址`str`，如果一开始就遇到文件尾或读数据失败则返回`NULL`。

`fputs(str, fp)`:

把`str`所指向的字符串写到文件指针变量`fp`指向的文件中（不包含`'\0'`），输出成功返回0，否则返回一个非零值。（str可以是字符串常量）


```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    char a[10];
    FILE *fp = fopen("G:\\clion\\78.txt", "r");
    if (fp == NULL) {

        printf("文件打开失败，程序退出\n");
        exit(-1);
    }
    // 程序第一次调用该语句 a数组的内容为 “123456\n" 读到换行符，fgets函数结束读入
    fgets(a, 10, fp); 
    fputs(a, stdout);
    // 程序第二次次调用该语句 a数组的内容为 “123456789" 读到最大容纳有效字符个数9时，fgets读入结束
    fgets(a, 10, fp); 
    fputs(a, stdout);
    // 程序第二次次调用该语句 a数组的内容为 “abcdefg" 读到文件末尾时，fgets函数读入结束
    fgets(a, 10, fp); 
    fputs(a, stdout);
    putchar('\n');
    //把从键盘上输入的数据使用fgets和fputs输出在屏幕上
    while (fgets(a, 10, stdin) != NULL) {
        fputs(a, stdout);
    }
    fclose(fp);
    fp = NULL;
    return 0;
}
```

## 格式化输入输出
printf和scanf函数是向终端进行格式化的输入输出。
如果向文件进行格式化输入输出需要用到fprintf和fscanf函数。调用方式如下：
+ fprintf(文件指针,格式字符串,输出列表);
+ fscanf(文件指针,格式字符串,输出列表);

> 注：输入时要将文件中的ASCII码转换成二进制形式保存在内存变量中，在输出时又要将内存中的二进制形式转换成字符，要花费较多的时间。

```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    FILE *p1 = fopen("G:\\codeOfc\\file\\79.txt", "r");
    if (p1 == NULL) {
        printf("文件打开失败，程序退出\n");
        exit(-1);
    }
    FILE *p2 = fopen("G:\\codeOfc\\file\\79-2.txt", "w");
    if (p2 == NULL) {
        printf("文件打开失败，程序退出\n");
        exit(-1);
    }
    int a;
    double b;
    char c[40];
    fscanf(p1, "%d%lf%s", &a, &b, c);
    printf("%d\n%.1lf\n%s\n", a, b, c);
    fprintf(p2, "%d\n%.1lf\n%s\n", a, b, c);
    fclose(p1);
    fclose(p2);
    p1 = NULL;
    p2 = NULL;
    return 0;
}
```

## 二进制方式读写
1. fread（buffer, size, count, fp）;从fp所指向的文件中读数据，最多读取count个项，每个项size个字节，并把这些数据存放到以buffer为地址开头的内存块中，如果调用成功返回实际读取到的项个数（小于或等于count），如果不成功或一开始读到文件末尾返回 0。

2. fwrite（buffer, size, count, fp）;把以buffer为地址开头的内存块的count个项的size个字节的数据写入fp所指向的文件中， 返回实际写入的数据项个数count。
```c
#include <stdio.h>
#include <stdlib.h>
typedef struct {
    char name[30];
    double score;
} Stu;

int main() {
    Stu a[3] = {{"zhangsan", 85}, {"lisi", 78}, {"wangwu", 99}};
    FILE *p1 = fopen("G:\\codeOfc\\file\\80.txt", "wb");
    if (p1 == NULL) {
        printf("文件打开失败，程序退出\n");
        exit(-1);
    }
    fwrite(a, sizeof(Stu), 3, p1);
    fclose(p1);
    p1 = fopen("G:\\codeOfc\\file\\80abc.txt", "rb");
    Stu b[3];
    fread(b, sizeof(Stu), 3, p1);
    for (int i = 0; i < 3; i++) {
        printf("第%d个学生的姓名：%s，成绩：%lf\n", i + 1, b[i].name,
               b[i].score);
    }
    fclose(p1);
    return 0;
}
```
## 随机读写数据文件

1. 随机读写不是按数据在文件中的物理次序进行读写，而是可以对任何位置上的数据进行访问，显然这种方式比顺序访问效率高的多。

2. 文件位置标记简称文件标记，用来指示“接下来要读写的下一个字符的位置”（有的地方还称其为“文件位置指针”或“文件指针”，这里和我们c语言中的指针完全是两回事）

3. `rewind(fp)`：使`fp`所指向的文件的文件标记到文件的开头位置，此函数没有返回值。

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   int main() {
       FILE *p = fopen("G:\\codeOfc\\file\\84.txt", "a+");
       if (p == NULL) {
           printf("文件打开失败，程序退出\n");
           exit(-1);
       }
       char ch;
       while ((ch = getc(stdin)) != EOF) {
           putc(ch, p);
       }
       rewind(p); // 使文件标记回到文件开头
       while ((ch = getc(p)) != EOF) {
           putc(ch, stdout);
       }
   
       return 0;
   }
   ```

   

4. `fseek`(文件类型指针,位移量,起始点);可改变文件标记，执行成功返回0，否则返回非0值。
    起始点可用0或1或2代替，含义如下：

|    起始点    |   名字   | 用数字代表 |
| :----------: | :------: | :--------: |
| 文件开始位置 | SEET_SET |     0      |
| 文件当前位置 | SEEK_CUR |     1      |
| 文件末尾位置 | SEEK_END |     2      |

  > 位移量指以起始点为基点，向后移动的字节数。位移量是long型数据（在末尾加L，就表示long型）

  5. `ftell(fp)`：用于得到`fp`所指向的文件的文件标记相对于文件首的偏移字节数，返回值为`long`型，出错会返回`-1L`。
