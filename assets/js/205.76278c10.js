(window.webpackJsonp=window.webpackJsonp||[]).push([[205],{778:function(_,v,a){"use strict";a.r(v);var t=a(7),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"面向对象的概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的概念"}},[_._v("#")]),_._v(" 面向对象的概念")]),_._v(" "),a("p",[_._v("Coad 和 Yourdon 给出的”面向对象“的定义如下：")]),_._v(" "),a("p",[_._v("面向对象 = 对象 + 类 + 继承 + 消息通信")]),_._v(" "),a("p",[_._v("如果一个系统是使用上述 4 个概念设计和实现的，则可认为这个系统是面向对象的。面向对象程序的基本组成单位是类。程序在运行时由类产生对象，对象之间通过发送消息进行通信，相互协作完成相应功能。对象是面向对象程序的核心。")]),_._v(" "),a("h3",{attrs:{id:"面向对象的软件开发方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的软件开发方法"}},[_._v("#")]),_._v(" 面向对象的软件开发方法")]),_._v(" "),a("h4",{attrs:{id:"booch-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#booch-方法"}},[_._v("#")]),_._v(" Booch 方法")]),_._v(" "),a("p",[_._v("Booch 方法包含“微开发过程”和“宏开发过程”。微开发过程定义了一组任务，并在宏开发过程的每一步骤中反复使用他们，以维持演进途径。Booch 的 OOA 宏开发过程包括以下任务：")]),_._v(" "),a("ol",[a("li",[_._v("标识类和对象")]),_._v(" "),a("li",[_._v("标识类和对象的语义")]),_._v(" "),a("li",[_._v("标识类和对象间的关系")]),_._v(" "),a("li",[_._v("进行一系列精化")]),_._v(" "),a("li",[_._v("实现类和对象")])]),_._v(" "),a("h4",{attrs:{id:"rumbaugh-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rumbaugh-方法"}},[_._v("#")]),_._v(" Rumbaugh 方法")]),_._v(" "),a("p",[_._v("Rumbaugh 和他的同时提出的对象建模技术用于系统分析、系统设计和对象级设计。分析活动建立以下3种模型：")]),_._v(" "),a("ol",[a("li",[_._v("对象模型：描述对象、类、层次和关系")]),_._v(" "),a("li",[_._v("动态模型：描述对象和系统的行为")]),_._v(" "),a("li",[_._v("功能模型：类似于高层的 DFD，描述穿越系统的信息流")])]),_._v(" "),a("h4",{attrs:{id:"coad-和-yourdon-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coad-和-yourdon-方法"}},[_._v("#")]),_._v(" Coad 和 Yourdon 方法")]),_._v(" "),a("p",[_._v("OOA 过程概述如下：")]),_._v(" "),a("ol",[a("li",[_._v("使用“要找什么”准则表示对象")]),_._v(" "),a("li",[_._v("定义对对象之间的一般化/特殊化结构（又称为继承结构）")]),_._v(" "),a("li",[_._v("定义对象之间的整体/部分结构（又称为组装结构）")]),_._v(" "),a("li",[_._v("标识主题（系统构建的表示）")]),_._v(" "),a("li",[_._v("定义对象的属性及对象之间的实例连接")]),_._v(" "),a("li",[_._v("定义服务及对象之间的消息连接")])]),_._v(" "),a("h4",{attrs:{id:"jacobson-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jacobson-方法"}},[_._v("#")]),_._v(" Jacobson 方法")]),_._v(" "),a("p",[_._v("Jacoboson 方法也称为 OOSE（面向对象软件工程）方法，它与其他方法的不同之处在于特别强调用例，概述如下：")]),_._v(" "),a("ol",[a("li",[_._v("表示系统的用户和他们的整体责任")]),_._v(" "),a("li",[_._v("通过定义参与者及其职责、用例、对象和关系的初步视图，建立需求模型")]),_._v(" "),a("li",[_._v("通过标识界面对象、建立界面对象的结构视图、表示对象行为、分离出每个对象的子系统和模型，建立分析模型")])]),_._v(" "),a("h4",{attrs:{id:"wirfs-brock-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#wirfs-brock-方法"}},[_._v("#")]),_._v(" Wirfs-Brock 方法")]),_._v(" "),a("p",[_._v("该方法不要求明确地区分分析和设计任务，从评估客户规格说明到设计完成，是一个连续的过程，任务概述如下：")]),_._v(" "),a("ol",[a("li",[_._v("评估客户规格说明")]),_._v(" "),a("li",[_._v("使用语法分析从规格说明中提取候选类")]),_._v(" "),a("li",[_._v("将类分组以表示超类")]),_._v(" "),a("li",[_._v("定义每一个类的职责")]),_._v(" "),a("li",[_._v("将职责赋予每个类")]),_._v(" "),a("li",[_._v("标识类之间的关系")]),_._v(" "),a("li",[_._v("基于职责定义类之间的协作")]),_._v(" "),a("li",[_._v("建立类的层次结构")]),_._v(" "),a("li",[_._v("构造系统的协作图")])]),_._v(" "),a("h2",{attrs:{id:"uml-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#uml-简介"}},[_._v("#")]),_._v(" UML 简介")]),_._v(" "),a("h3",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[_._v("#")]),_._v(" 特点")]),_._v(" "),a("ol",[a("li",[_._v("统一标准")]),_._v(" "),a("li",[_._v("面向对象")]),_._v(" "),a("li",[_._v("可视化")]),_._v(" "),a("li",[_._v("独立于过程")]),_._v(" "),a("li",[_._v("容易掌握使用")]),_._v(" "),a("li",[_._v("与编程语言的关系")])]),_._v(" "),a("h3",{attrs:{id:"基本模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本模型"}},[_._v("#")]),_._v(" 基本模型")]),_._v(" "),a("p",[a("img",{attrs:{src:"/soft_engineering/image-20210305134102665.png",alt:"image-20210305134102665"}})]),_._v(" "),a("p",[_._v("UML 的基本模型由事务、关系和图组成。")])])}),[],!1,null,null,null);v.default=r.exports}}]);