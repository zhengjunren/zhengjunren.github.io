(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{396:function(t,a,_){"use strict";_.r(a);var v=_(5),r=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"软件体系结构与设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#软件体系结构与设计模式"}},[t._v("#")]),t._v(" 软件体系结构与设计模式")]),t._v(" "),_("h2",{attrs:{id:"软件体系结构概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#软件体系结构概念"}},[t._v("#")]),t._v(" 软件体系结构概念")]),t._v(" "),_("h2",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),_("p",[t._v("一个模式有 4 个基本的要素：模式名称、问题、解决方案、效果")]),t._v(" "),_("h3",{attrs:{id:"抽象工厂模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式"}},[t._v("#")]),t._v(" 抽象工厂模式")]),t._v(" "),_("p",[t._v("抽象工厂模式提供一个接口用以创建一个相联系或相依赖的对象族，而无须指定他们的具体类。")]),t._v(" "),_("p",[t._v("抽象工厂类：声明创建抽象产品对象的操作接口。")]),t._v(" "),_("p",[t._v("具体工厂类：实现产生具体对象的操作")]),t._v(" "),_("p",[t._v("抽象产品类：声明一种产品对象的接口")]),t._v(" "),_("p",[t._v("具体产品类：定义将被相应的具体工厂类产生的产品对象，并实现抽象产品类的接口。")]),t._v(" "),_("p",[t._v("客户：仅使用由抽象工厂类和抽象产品类声明的接口")]),t._v(" "),_("p",[_("img",{attrs:{src:"/soft_engineering/image-20210314140348988.png",alt:"image-20210314140348988"}})]),t._v(" "),_("h3",{attrs:{id:"单例模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[t._v("#")]),t._v(" 单例模式")]),t._v(" "),_("p",[t._v("在单例模式中，一个类只有一个实例并提供一个访问它的全局访问点，该实例应在系统生存期中都存在。")]),t._v(" "),_("h3",{attrs:{id:"外观模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#外观模式"}},[t._v("#")]),t._v(" 外观模式")]),t._v(" "),_("p",[t._v("外观模式给子系统中的一组接口提供一套统一的高层界面，使得子系统更容易使用。如三层架构中的 service 层")]),t._v(" "),_("p",[t._v("外观：知道子系统中哪个类负责处理哪种信息；并负责把外界输入的信息转给适当的子系统对象")]),t._v(" "),_("p",[t._v("子系统类：实现子系统的功能；处理 外观对象分派的工作；")]),t._v(" "),_("h3",{attrs:{id:"适配器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[t._v("#")]),t._v(" 适配器模式")]),t._v(" "),_("p",[t._v("适配器模式将一个类的接口转换成为客户期望的另一种接口，使得原本因接口不匹配而无法合作的类一起工作。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/soft_engineering/image-20210314195128184.png",alt:"image-20210314195128184"}})]),t._v(" "),_("p",[t._v("目标：定义客户使用的与应用领域相关的接口")]),t._v(" "),_("p",[t._v("客户：与具有 Target 接口的对象合作。")]),t._v(" "),_("p",[t._v("被匹配者：需要被转换匹配的一个已存在的接口")]),t._v(" "),_("p",[t._v("适配器：将被匹配这的接口与 Target 接口匹配")]),t._v(" "),_("h3",{attrs:{id:"职责链模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#职责链模式"}},[t._v("#")]),t._v(" 职责链模式")]),t._v(" "),_("p",[t._v("职责链模式通过一条隐式的对象消息链传递处理请求。该请求沿着这条链传递，直到有个对象处理为止。其核心就是避免将请求的发送者直接耦合到它的接受者。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/soft_engineering/image-20210314195048378.png",alt:"image-20210314195048378"}})]),t._v(" "),_("p",[t._v("处理者：定义处理请求的接口；实现对后继者的链接。")]),t._v(" "),_("p",[t._v("具体处理者：处理它所负责的请求；可以访问它的后继；如果它能处理请求，就处理该请求，否则将请求传递给后继者。")]),t._v(" "),_("p",[t._v("客户：将处理请求提交给职责链中的具体处理者")]),t._v(" "),_("h3",{attrs:{id:"中介者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#中介者模式"}},[t._v("#")]),t._v(" 中介者模式")]),t._v(" "),_("p",[t._v("中介者模式用一个中介对象来封装一系列复杂对象的交互情景。中介中通过阻止各个对象显示地相互引用来降低它们之间的耦合，使得人们可以独立地改变它们之间的交互。")]),t._v(" "),_("p",[t._v("中介者：定义与各个同事对象通信的接口")]),t._v(" "),_("p",[t._v("具体中介者：协调各个同事对象，实现协作行为；了解并维护各个同时对象。")]),t._v(" "),_("p",[t._v("同事类：这些同事类的对象都了解中介者；一个同事对象与另一个同事对象之间的通信需要通过中介者来实现")]),t._v(" "),_("h3",{attrs:{id:"观察者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[t._v("#")]),t._v(" 观察者模式")]),t._v(" "),_("p",[t._v("观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知，并被自动更新。")]),t._v(" "),_("p",[t._v("主题（Subject）：认识它的观察者。任意观察者对象均可订阅同一个主题。另外，提供一个连接观察者对象和接触连接的接口")]),t._v(" "),_("p",[t._v("观察者：定义了一个自我更新的接口，一旦发现主题有变时借助接口通知自己随之改变")]),t._v(" "),_("p",[t._v("具体主题：存储具体观察者对象关心的状态，当状态改变时想他的观察者发送通知")]),t._v(" "),_("p",[t._v("具体观察者：位置一个对具体主题对象的引用，存储与主题一致的状态，实现观察者自我更新接口，确保自己的状态和主题一致。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/soft_engineering/image-20210314194440852.png",alt:"image-20210314194440852"}})])])}),[],!1,null,null,null);a.default=r.exports}}]);