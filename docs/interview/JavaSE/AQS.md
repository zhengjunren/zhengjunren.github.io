---
title: AQS
date: 2021-01-24
---

## AbstractQueuedSynchronizer

通过内置的队列来完成资源获取线程的排队工作，并通过一个 int 类型变量表示持有锁的状态

![image-20210124165245043](/interview/image-20210124165245043.png)

![image-20210124165319381](/interview/image-20210124165319381.png)

![image-20210124165433352](/interview/image-20210124165433352.png)

抢到资源的线程直接使用处理业务逻辑，抢不到资源的必然涉及一种排队等候机制。抢占资源失败的线程继续去等待（类似银行办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等待），但等候的线程仍然保留获取锁的可能且获取锁的流程仍在继续（候客区的顾客也在等待着叫号，轮到了再去受理窗口办理业务）

·如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁的分配。这个机制主要用的是 CLH 队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是 AQS 的抽象变现。它将请求共享资源的线程封装成队列的节点（Node），通过 CAS 、自旋以及 LockSupport.park() 的方式，维护 state 变量的状态，是并发达到同步的控制效果

AQS 使用一个 volatile 的 int 类型的成员变量来表示同步状态，通过内置的队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个 Node 节点来实现锁的分配，通过 CAS 来完成对 state 值的修改

