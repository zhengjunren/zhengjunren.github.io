(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{397:function(v,_,a){"use strict";a.r(_);var t=a(5),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"面向对象设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象设计"}},[v._v("#")]),v._v(" 面向对象设计")]),v._v(" "),a("h2",{attrs:{id:"面向对象设计过程和准则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象设计过程和准则"}},[v._v("#")]),v._v(" 面向对象设计过程和准则")]),v._v(" "),a("h3",{attrs:{id:"面向对象设计过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象设计过程"}},[v._v("#")]),v._v(" 面向对象设计过程")]),v._v(" "),a("p",[v._v("面向对象的设计过程一般有以下几个阶段")]),v._v(" "),a("ol",[a("li",[v._v("建立系统环境模型")]),v._v(" "),a("li",[v._v("设计系统体系结构")]),v._v(" "),a("li",[v._v("对各个子系统进行设计")]),v._v(" "),a("li",[v._v("对象设计及优化")])]),v._v(" "),a("h3",{attrs:{id:"面向对象设计准则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象设计准则"}},[v._v("#")]),v._v(" 面向对象设计准则")]),v._v(" "),a("ol",[a("li",[v._v("模块化\n"),a("ul",[a("li",[v._v("传统的面向过程方法中的模块通常是函数、过程及程序等，而面向对象方法中的模块则是类、对象、结构、构件等")]),v._v(" "),a("li",[v._v("在面向过程的方法中，数据及在数据上的处理是分离的，而在面向对象方法中，书记及其上的处理是封装在一起的，具有更好的独立性，也能够更好的支持复用")])])]),v._v(" "),a("li",[v._v("抽象\n"),a("ul",[a("li",[v._v("面向对象方法不仅支持过程抽象，而且支持数据抽象，类实际是一种抽象数据类型，可以将类的抽象分为规格说明抽象及参数化抽象")]),v._v(" "),a("li",[v._v("类对外开放的公共接口构成了类的规格说明，即协议。这种接口规定了外部可以使用的服务，使用者无需知道这些服务的具体实现算法，通常将这类抽象称为规格说明抽象。")]),v._v(" "),a("li",[v._v("参数化抽象是指当描述类的规格说明并不具体指定所要操作的数据类型，而是将数据类型作为参数。")])])]),v._v(" "),a("li",[v._v("信息隐蔽\n"),a("ul",[a("li",[v._v("在面向对象方法中，信息隐蔽通过对象的封装性实现。对于类的使用户来说，属性的表示方法和操作实现算法都应该是隐蔽的，封装是手段，它的目的是达到信息隐蔽。")])])]),v._v(" "),a("li",[v._v("弱耦合\n"),a("ul",[a("li",[v._v("耦合是指一个软件结构之间互连的紧密程度，在面向对象方法中，对象是最基本的模块，因此耦合只要指不同对象之间相互关联的紧密程度")])])]),v._v(" "),a("li",[v._v("强内聚\n"),a("ul",[a("li",[v._v("内聚是衡量一个模块内各个元素批次结合的紧密程度，在 OOD 中存在以下 3 中内聚\n"),a("ul",[a("li",[v._v("服务内聚：一个服务应该完成一个且仅一个功能。")]),v._v(" "),a("li",[v._v("类内聚：设计类的原则是，一个类应该只有一个用途，它的属性和服务应该是高内聚的。类的属性和服务应该全都是完成该类对象的任务锁必须的，其中不包含无用的属性或服务。如果某个类有多个用途，通常应该把它分解成多个专用的类。")]),v._v(" "),a("li",[v._v("一般-特殊内聚：设计出的一般-特殊结构，应该符合多数人的概念，更准确的说，这种结构应该是对相应的领域知识的正确抽象")])])])])]),v._v(" "),a("li",[v._v("可重用\n"),a("ul",[a("li",[v._v("软件重用是提高软件开发生产率和目标系统质量的重要途径")]),v._v(" "),a("li",[v._v("重用基本上从设计阶段开始，有两方面的含义：\n"),a("ul",[a("li",[v._v("尽量使用已有的类（包括开发环境提供的类库，以及以往开发类似系统时创建的类）")]),v._v(" "),a("li",[v._v("如果确实需要创建新类，则在设计这些新类的协议时，应该考虑将来的可重复实用性")])])])])])]),v._v(" "),a("h2",{attrs:{id:"体系结构模块及依赖性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#体系结构模块及依赖性"}},[v._v("#")]),v._v(" 体系结构模块及依赖性")]),v._v(" "),a("p",[v._v("体系狗设计描述了简历计算机系统所需要的"),a("strong",[v._v("数据结构")]),v._v("和"),a("strong",[v._v("程序构件")]),v._v("。一个好的体系结构设计要求"),a("strong",[v._v("软件模块的分层和编程标准的执行")])]),v._v(" "),a("p",[v._v("在面向对象软件中，常见的软件模块有类、接口、包和构件")]),v._v(" "),a("p",[v._v("在设计阶段我们往往关注类、接口和包，在实现阶段关注构件，而在部署阶段则关注构件的部署，也就是将构件部署在哪些节点上。")]),v._v(" "),a("h3",{attrs:{id:"类及其依赖性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类及其依赖性"}},[v._v("#")]),v._v(" 类及其依赖性")]),v._v(" "),a("h4",{attrs:{id:"类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[v._v("#")]),v._v(" 类")]),v._v(" "),a("p",[v._v("在面向对象的程序设计重，类和接口实参恒旭的最基本组成单元。一个典型的程序需要界面类负责用户界面信息，需要数据库类负责与数据库进行交互，需要业务逻辑类负责算法计算等。要设计和实现的所有类应该具有唯一的名字，在不同的阶段或从不同的角度可以将他们称为设计类、实现类、系统类或应用类等。")]),v._v(" "),a("h4",{attrs:{id:"继承依赖性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承依赖性"}},[v._v("#")]),v._v(" 继承依赖性")]),v._v(" "),a("p",[v._v("继承是一种在父类和子类之间共性属性和行为的方式。")]),v._v(" "),a("ol",[a("li",[v._v("多态继承\n"),a("ul",[a("li",[v._v("根据为不同提冲服务的对象不同可以得到不同的行为，这种线程称为多态")]),v._v(" "),a("li",[v._v("多态并不是伴随着继承而出现的。如果在子类中不覆盖父类中的任何方法，就不会产生多态行为")]),v._v(" "),a("li",[v._v("集成会带来类和方法之间的依赖性，集成带来的依赖性有编译时集成依赖性和运行时集成依赖性，一般来说都会引入编译时集成依赖性，依赖性是可传递的")])])]),v._v(" "),a("li",[v._v("无多态集成")]),v._v(" "),a("li",[v._v("拓展继承和约束继承\n"),a("ul",[a("li",[v._v("拓展集成是指子类继承父类的属性，并提供额外属性来增强类定义")]),v._v(" "),a("li",[v._v("当一个类覆盖了继承来的方法，并对一些集成来到额功能进行了限制，这时就产生了约束继承")])])])]),v._v(" "),a("h4",{attrs:{id:"交互依赖性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#交互依赖性"}},[v._v("#")]),v._v(" 交互依赖性")]),v._v(" "),a("p",[v._v("也称为方法依赖性，是通过消息连接产生的")]),v._v(" "),a("h3",{attrs:{id:"接口及其依赖性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口及其依赖性"}},[v._v("#")]),v._v(" 接口及其依赖性")]),v._v(" "),a("h4",{attrs:{id:"接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[v._v("#")]),v._v(" 接口")]),v._v(" "),a("p",[v._v("接口在 UML2.0 中，接口是不可直接实例化的特性集合的生命，即其对象不能直接实例化，需要通过类来实现，实现接口的类需要实现接口中声明的方法。")]),v._v(" "),a("p",[v._v("由于允许在接口中存在属性，因此，在接口之间或者接口和类之间可能会产生关联，用另一个接口或类作为属性的类型可以表示关联。接口和抽象类有相似支取，抽象类至少包括一个没有实现的方法的类，若果一个抽象类中所有方法都没有实现，则称其为纯抽象类，从这一点上接口和抽象类似乎没有区别，但实际上，接口和抽象列还是有着本质的区别。在只支持单继承的语言中，一个类只能有一个直接父类，但却可以实现多个接口")]),v._v(" "),a("h4",{attrs:{id:"实现依赖性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现依赖性"}},[v._v("#")]),v._v(" 实现依赖性")]),v._v(" "),a("p",[v._v("一个类可以实现多个接口，由类实现的接口集合称为该类的供给接口。在 UML2.0 中，将一个类和该类实现的接口之间的依赖性称为实现依赖性")]),v._v(" "),a("h4",{attrs:{id:"使用依赖性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用依赖性"}},[v._v("#")]),v._v(" 使用依赖性")]),v._v(" "),a("p",[v._v("一个接口可以为其他类或接口提供服务，同时也可能需要其他接口的服务，一个接口所需要的其他接口所提供的服务称为这个类的需求接口。")]),v._v(" "),a("h3",{attrs:{id:"包及其依赖性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#包及其依赖性"}},[v._v("#")]),v._v(" 包及其依赖性")]),v._v(" "),a("p",[v._v("包又称为层或子系统，是表示组织类的中方式，用于划分应用程序的剧哦及模型")]),v._v(" "),a("p",[v._v("包可以嵌套，包还可以导入其他包")]),v._v(" "),a("h3",{attrs:{id:"构件及其依赖性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构件及其依赖性"}},[v._v("#")]),v._v(" 构件及其依赖性")]),v._v(" "),a("p",[v._v("在面向对象的额软件工程软件环境中，面向对象技术已达到了类级复用，而构件级复用则是比类级复用更高一级的复用，它是对一组类的组合进行了封装，并代表完成一个或多个功能的特定服务，也为用户提供了多个接口")]),v._v(" "),a("p",[v._v("一个构件可以是一个编译的类、可以是一组搬移的类，也可以是其他独立的部署单元，如一个文件、一个图片、一个数据文件一个脚本等")]),v._v(" "),a("p",[v._v("从软件复用的角度，构件是指在软件开发的过程中可以重复使用的元素，这些软件元素包括程序代码、测试用例、设计文档、设计过程、需求分析文档、甚至领域知识。可复用的软件元素越大，我们称可复用的粒度越大，为了能够支持复用，软件构建应具有以下特性：")]),v._v(" "),a("ol",[a("li",[v._v("独立部署单元，一个构件是独立部署的，一位着它必须能够与它所在的环境及其他构建完全分离")]),v._v(" "),a("li",[v._v("作为第三方的组装单元：构件必须举杯很好的内聚性，必须封装它内部的实现，并且只通过良好定义的接口与外部环境交互")]),v._v(" "),a("li",[v._v("一个构件不能有任何（外部的）可见状态：即构件不能与自己的拷贝有所区别")])]),v._v(" "),a("p",[v._v("软件构件是一种组装单元，它具有规范的接口规格说明和显示的语境依赖。软件构件可以被独立部署，并且由第三方任意组装")]),v._v(" "),a("p",[v._v("OMF UML 规范中将构件定义为“系统中某一定型化的、可配置的和可替换的部件，该部件封装了实现并暴露一系列接口")]),v._v(" "),a("p",[v._v("构件和类的区别是双重的：首先，构件是不出在某个计算机节点的物理抽象。类表示逻辑事务，为了起到物理抽象作用，不得不将其实现为构件。其次，构件只显示它包含的类的某些接口，很多其他接口都被封装在构件中-他们纸杯协作的类在内部使用，对于其他构件是不可见的。")]),v._v(" "),a("h2",{attrs:{id:"系统分解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统分解"}},[v._v("#")]),v._v(" 系统分解")]),v._v(" "),a("h3",{attrs:{id:"coad-yourdon-面向对象设计模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#coad-yourdon-面向对象设计模型"}},[v._v("#")]),v._v(" Coad & Yourdon 面向对象设计模型")]),v._v(" "),a("p",[v._v("Coad & Yourdon 基于 MVC 模型，在逻辑上将系统划分为四个部分，分别是问题域部分，人机交互部分，任务管理部分以及数据管理部分，每一部分又可分为若干个子系统。在不同的软件系统中，这四个部分的重要程度和规模可能相差很大，在设计过程中可以将规模过大的子系统进一步划分为更小的子系统，规模过小的则可以合并到其他系统中")]),v._v(" "),a("p",[v._v("Coad & Yourdon 在设计阶段中继续采用了分析阶段中提到的五个层次，用于建立系统的四个组成部分。每个子系统都由主题、类-对象、结构、属性和服务五个层次组成。")]),v._v(" "),a("h2",{attrs:{id:"问题域部分的设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题域部分的设计"}},[v._v("#")]),v._v(" 问题域部分的设计")]),v._v(" "),a("p",[v._v("典型的面型对象系统一般由三层组成，即数据库层、业务逻辑层和用户界面层")]),v._v(" "),a("p",[v._v("面向想设计应该从问题域部分的设计开始，也就是三层结构的中间层：业务逻辑层")]),v._v(" "),a("h2",{attrs:{id:"问题域部分的设计-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题域部分的设计-2"}},[v._v("#")]),v._v(" 问题域部分的设计")]),v._v(" "),a("h2",{attrs:{id:"人机交互部分的设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#人机交互部分的设计"}},[v._v("#")]),v._v(" 人机交互部分的设计")]),v._v(" "),a("h2",{attrs:{id:"任务管理部分的设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务管理部分的设计"}},[v._v("#")]),v._v(" 任务管理部分的设计")]),v._v(" "),a("h2",{attrs:{id:"数据管理部分的设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据管理部分的设计"}},[v._v("#")]),v._v(" 数据管理部分的设计")]),v._v(" "),a("h2",{attrs:{id:"对象设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象设计"}},[v._v("#")]),v._v(" 对象设计")])])}),[],!1,null,null,null);_.default=r.exports}}]);