(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{321:function(a,h,t){"use strict";t.r(h);var s=t(5),e=Object(s.a)({},(function(){var a=this,h=a.$createElement,t=a._self._c||h;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"hashmap相关问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap相关问题"}},[a._v("#")]),a._v(" HashMap相关问题")]),a._v(" "),t("h2",{attrs:{id:"hashmap的底层原理是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的底层原理是什么"}},[a._v("#")]),a._v(" HashMap的底层原理是什么？")]),a._v(" "),t("p",[a._v("基于hashing的原理，jdk8后采用数组+链表+红黑树的数据结构。通过put和get存储和获取对象。当给put()方法传递键和值时，先对键做一个hashCode()的计算来得到它在bucket数组中的位置来存储Entry对象。当获取对象时，通过get获取到bucket的位置，再通过键对象的equals()方法找到正确的键值对，然后在返回值对象。")]),a._v(" "),t("h2",{attrs:{id:"hashmap中put是如何实现的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap中put是如何实现的"}},[a._v("#")]),a._v(" HashMap中put是如何实现的？")]),a._v(" "),t("ol",[t("li",[a._v("计算关于key的hashcode值（与Key.hashCode的高16位做异或运算）")]),a._v(" "),t("li",[a._v("如果散列表为空时，调用resize()初始化散列表")]),a._v(" "),t("li",[a._v("如果没有发生碰撞，直接添加元素到散列表中去")]),a._v(" "),t("li",[a._v("如果发生了碰撞(hashCode值相同)，进行三种判断\n"),t("ul",[t("li",[a._v("若key地址相同或者equals后内容相同，则替换旧值")]),a._v(" "),t("li",[a._v("如果是红黑树结构，就调用树的插入方法")]),a._v(" "),t("li",[a._v("链表结构，循环遍历直到链表中某个节点为空，尾插法进行插入，插入之后判断链表个数是否到达变成红黑树的阙值8；也可以遍历到有节点与插入元素的哈希值和内容相同，进行覆盖。")])])]),a._v(" "),t("li",[a._v("如果桶满了大于阀值，则resize进行扩容")])]),a._v(" "),t("h2",{attrs:{id:"hashmap中get是如何实现的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap中get是如何实现的"}},[a._v("#")]),a._v(" HashMap中get是如何实现的？")]),a._v(" "),t("p",[a._v("对key的hashCode进行hashing，与运算计算下标获取bucket位置，如果在桶的首位上就可以找到就直接返回，否则在树中找或者链表中遍历找，如果有hash冲突，则利用equals方法去遍历链表查找节点。")]),a._v(" "),t("h2",{attrs:{id:"为什么不直接将key作为哈希值而是与高16位做异或运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么不直接将key作为哈希值而是与高16位做异或运算"}},[a._v("#")]),a._v(" 为什么不直接将key作为哈希值而是与高16位做异或运算？")]),a._v(" "),t("p",[a._v("因为数组位置的确定用的是与运算，仅仅最后四位有效，设计者将key的哈希值与高16为做异或运算使得在做&运算确定数组的插入位置时，此时的低位实际是高位与低位的结合，增加了随机性，减少了哈希碰撞的次数。")]),a._v(" "),t("h2",{attrs:{id:"初始化值为什么必须是2的幂"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化值为什么必须是2的幂"}},[a._v("#")]),a._v(" 初始化值为什么必须是2的幂？")]),a._v(" "),t("p",[a._v("HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；\n这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&(length-1)，\nhash%length==hash&(length-1)的前提是length是2的n次方；")]),a._v(" "),t("p",[a._v("扩容之后，原始数据的在数组中的数据要么不变，要么加上扩容之后的一半")])])}),[],!1,null,null,null);h.default=e.exports}}]);