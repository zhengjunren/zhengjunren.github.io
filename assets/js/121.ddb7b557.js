(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{427:function(a,e,t){"use strict";t.r(e);var n=t(5),r=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"spring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[a._v("#")]),a._v(" Spring")]),a._v(" "),t("h2",{attrs:{id:"spring-有几种注入方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-有几种注入方式"}},[a._v("#")]),a._v(" Spring 有几种注入方式")]),a._v(" "),t("ol",[t("li",[a._v("手动注入\n"),t("ul",[t("li",[a._v("set 方法注入")]),a._v(" "),t("li",[a._v("构造方法注入")])])]),a._v(" "),t("li",[a._v("自动注入\n"),t("ul",[t("li",[a._v("XML 自动注入\n"),t("ul",[t("li",[a._v("set 方法")]),a._v(" "),t("li",[a._v("构造方法")])])]),a._v(" "),t("li",[a._v("@Autowired 注解自动注入(先 byType, 后 byName)\n"),t("ul",[t("li",[a._v("属性")]),a._v(" "),t("li",[a._v("构造方法")]),a._v(" "),t("li",[a._v("set 方法")])])])])])]),a._v(" "),t("h2",{attrs:{id:"bean-的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bean-的生命周期"}},[a._v("#")]),a._v(" Bean 的生命周期")]),a._v(" "),t("h3",{attrs:{id:"bean-定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bean-定义"}},[a._v("#")]),a._v(" Bean 定义")]),a._v(" "),t("ol",[t("li",[a._v("singleton: 在Spring的IoC容器中只存在一个对象实例，所有该对象的引用都共享这个实例。Spring 容器只会创建该bean定义的唯一实例，这个实例会被保存到缓存中，并且对该bean的所有后续请求和引用都将返回该缓存中的对象实例，一般情况下，无状态的bean使用该scope。")]),a._v(" "),t("li",[a._v("prototype:每次对该bean的请求都会创建一个新的实例，一般情况下，有状态的bean使用该scope。")]),a._v(" "),t("li",[a._v("request：每次http请求将会有各自的bean实例，类似于prototype。")]),a._v(" "),t("li",[a._v("session：在一个http session中，一个bean定义对应一个bean实例。")]),a._v(" "),t("li",[a._v("global session：在一个全局的http session中，一个bean定义对应一个bean实例。典型情况下，仅在使用portlet context的时候有效。")])]),a._v(" "),t("p",[a._v("其次说明spring的默认scope（bean作用域）是singleton")]),a._v(" "),t("h3",{attrs:{id:"生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[a._v("#")]),a._v(" 生命周期")]),a._v(" "),t("p",[a._v("class -> BeanDefinition -> BeanFactoryPostProcessor -> new 对象 -> 填充属性 -> aware -> 初始化 -> AOP -> 放置单例池 -> bean 对象")]),a._v(" "),t("h3",{attrs:{id:"实例化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例化"}},[a._v("#")]),a._v(" 实例化")]),a._v(" "),t("ul",[t("li",[a._v("实例化前：InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()")]),a._v(" "),t("li",[a._v("实例化：推断构造，new")]),a._v(" "),t("li",[a._v("实例化后：InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()")])]),a._v(" "),t("h3",{attrs:{id:"初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[a._v("#")]),a._v(" 初始化")]),a._v(" "),t("ul",[t("li",[a._v("Aware beanName")]),a._v(" "),t("li",[a._v("初始化前： BeanPostProcessor.postProcessBeforeInitialization()")]),a._v(" "),t("li",[a._v("初始化：InitializingBean")]),a._v(" "),t("li",[a._v("初始化后：AOP 代理对象-> BeanPostProcessor.postProcessAfterInitialization()")])]),a._v(" "),t("p",[a._v("BeanFactory")]),a._v(" "),t("p",[a._v("BeanFactoryPostProcessor")]),a._v(" "),t("h2",{attrs:{id:"beanfactory简介以及与factorybean的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#beanfactory简介以及与factorybean的区别"}},[a._v("#")]),a._v(" BeanFactory简介以及与FactoryBean的区别")]),a._v(" "),t("h3",{attrs:{id:"beanfactory"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#beanfactory"}},[a._v("#")]),a._v(" BeanFactory")]),a._v(" "),t("p",[a._v("它负责生产和管理bean的一个工厂。在Spring中，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如 DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，其中XmlBeanFactory就是常用的一个，该实现将以XML方式描述组成应用的对象及对象间的依赖关系。XmlBeanFactory类将持有此XML配置元数据，并用它来构建一个完全可配置的系统或应用。\n它为其他具体的IOC容器提供了最基本的规范，例如DefaultListableBeanFactory,XmlBeanFactory,ApplicationContext 等具体的容器都是实现了BeanFactory，再在其基础之上附加了其他的功能。")]),a._v(" "),t("h3",{attrs:{id:"factorybean"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#factorybean"}},[a._v("#")]),a._v(" FactoryBean")]),a._v(" "),t("p",[a._v("一般情况下，Spring通过反射机制利用"),t("code",[a._v("<bean>")]),a._v("的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在"),t("code",[a._v("<bean>")]),a._v("中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个"),t("code",[a._v("org.springframework.bean.factory.FactoryBean")]),a._v("的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean"),t("code",[a._v("<T>")]),a._v("的形式")]),a._v(" "),t("p",[a._v("以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean"),t("code",[a._v("<T>")]),a._v("接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&符号来获取。")]),a._v(" "),t("p",[a._v("FactoryBean是一个接口，当在IOC容器中的Bean实现了FactoryBean后，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject()方法返回的对象。要想获取FactoryBean的实现类，就要getBean(&BeanName)，在BeanName之前加上&。")])])}),[],!1,null,null,null);e.default=r.exports}}]);